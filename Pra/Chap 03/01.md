### 1.当在CUDA中展开循环、数据块或线程束时，可以提高性能的两个主要原因是什么？解释每种展开是如何提升指令吞吐量的。

如果同样要进行一千次计算，展开阶数为4的展开于不进行展开相比，减少了四分之三的分支循环。

同时展开能够提升编译器可发现的独立内存操作，其结果就是并行的内存读写操作数量上升以及内存带宽利用率的上升。

### 2.参考核函数reduceUnrolling8和实现核函数reduceUnrolling16，在这个函数中每个线程处理16个数据块。将该函数的性能与reduceUnrolling8内核性能进行比较，通过nvprof使用合适的指标与事件来解释性能差异。



### 3.参考核函数reduceUnrolling8，替换以下的代码段：使用下面在功能上等价的代码：比较每次的性能并解释使用nvprof指标的差异。

### 

### 4.参考核函数reduceCompleteUnrollWarps8。不要将vmem声明为volatile修饰符，而是使用`__syncthreads`。注意`__syncthreads`必须被线程块里的所有线程调用。比较两个核函数的性能并使用nvprof来解释所有的差异。



### 5.用C语言实现浮点数s的求和归约。



### 6.参考核函数reduceInterleaved和reduceCompleteUnrollWarps8，实现每个浮点数s的版本。比较它们的性能，选择合适的指标与/或事件来解释所有差异。它们相比于操作整数数据类型有什么不同吗？



### 7.被动态地产生孩子的全局数据进行更改，这种改变什么时候能保证对其父亲可见？



### 8.参考文件nestedHelloWorld.cu，用图330所示的方法实现一个新的核函数。



### 9.参考文件nestedHelloWorld.cu，实现一个新的核函数，使其可以用给定深度来限制嵌套层。